PHASE HOTFIX – Google Sheets Customer Backfill & Tolerant Import

You are working in the ServicePro v3 / Clean Machine repo.

Context:
- The “official” customer database for the app is the tenant-scoped customers table in Postgres (via Drizzle + wrapTenantDb). That’s what campaigns, rewards, and the AI agent use.
- We have two external sources of customer data:
  1) Google Voice SMS import (already populated ~1,900 customers).
  2) Google Sheet with at least two tabs: "Live Client Requests" and "Customer_Info_Sheet".
- Right now, only ~1,900 customers exist in the DB, which matches the Google Voice import count. That means the Google Sheets import/backfill is either not wired, only using one tab, or is too strict and skipping many rows.
- We need a tolerant importer + a one-time backfill to pull ALL available customers from those two sheets into the Postgres customer master.

GOAL:
- Implement a robust, tenant-aware Google Sheets → Customer DB import/backfill that:
  - Reads BOTH tabs: "Live Client Requests" and "Customer_Info_Sheet".
  - Creates a customer record even with partial data (phone OR email OR name, etc.).
  - Deduplicates/merges by phone/email so we don’t double count.
  - Ensures we end up with ~2,400+ unique customers for Clean Machine.
- Do this with minimal, additive changes; do NOT refactor existing systems or break anything.

==================================================
A) FIND EXISTING SHEET IMPORTER & CUSTOMER MODEL
==================================================

1) Search the repo for any existing Google Sheets integration related to customers:
   - Likely files include names like:
     - googleSheetsCustomerImporter.ts
     - sheetsCustomerSync.ts
     - customerImportService.ts
     - routes.googleSheets.ts
   - Also search for "Live Client Requests" and "Customer_Info_Sheet" to find where those tabs were previously referenced.

2) Identify the canonical customer DB model:
   - Find the Drizzle schema for the customers table (and any related tables such as phone numbers or emails).
     - It might be called "customers", "tenant_customers", or similar.
   - Confirm:
     - Primary key (customerId).
     - Tenant scoping (tenantId).
     - Columns for name, phone, email, city, etc.
   - Identify any helper services:
     - customerService.ts
     - customerRepository.ts
     - contactService.ts
   - We will use these helpers instead of writing raw SQL.

==================================================
B) DESIGN TOLERANT IMPORT LOGIC
==================================================

Create or update a dedicated importer service, something like:
- server/services/googleSheetsCustomerImportService.ts

This service should:

1) Talk to Google Sheets using the existing integration:
   - Use the same client as other sheet integrations (do NOT embed new auth flows).
   - Read the “Live Client Requests” tab.
   - Read the “Customer_Info_Sheet” tab.
   - Normalize each row into a common shape, e.g.:

     ```ts
     interface RawSheetCustomer {
       sourceTab: 'LiveClientRequests' | 'CustomerInfoSheet';
       fullName?: string;
       firstName?: string;
       lastName?: string;
       phone?: string;
       email?: string;
       city?: string;
       vehicleDescription?: string;
       notes?: string;
       // plus any other fields we already used
     }
     ```

2) Normalize phone and email:
   - Strip non-digits from phone numbers, handle leading +1, etc.
   - Accept that some phones will be landlines; do NOT reject them.
   - Lowercase and trim emails.

3) Build a tolerant "identity key":
   - If phone exists → use that as a primary match key.
   - Else if email exists → use that.
   - Else:
     - Use a combination like `${sourceTab}:${rowIndex}` purely as a dedupe key for that import run so we don’t import the same anonymous row twice.
   - The importer must NOT skip rows just because phone/email is missing; it should still create a customer with partial info and a generated internal ID.

4) Upsert logic:
   - For each normalized row:
     - Look up an existing customer in the tenant’s DB where:
       - phone matches (normalized), OR
       - email matches.
     - If found:
       - Merge data:
         - Fill in missing fields (name, email, city, vehicle, notes) if the DB record is blank and the sheet has a value.
         - Do NOT overwrite non-empty DB values with sheet values unless clearly better; prefer “fill blanks” behavior.
     - If not found:
       - Create a new customer record with:
         - tenantId = Clean Machine tenant
         - name/name fields (use whatever combination we have)
         - phone/email if present
         - any other metadata
       - Ensure a new customerId is generated by Drizzle.

5) Error tolerance:
   - If a row is totally unusable (e.g. all fields are blank), log it with a warning and skip.
   - Otherwise, do not throw; just log issues (e.g., invalid phone format) and continue.

6) Logging:
   - At the end of an import run, log a summary:

     ```ts
     console.log('[SHEETS IMPORT] Summary', {
       tenantId,
       sourceTabs: ['Live Client Requests', 'Customer_Info_Sheet'],
       totalRowsProcessed,
       newCustomersCreated,
       existingCustomersUpdated,
       rowsSkipped,
     });
     ```

==================================================
C) ONE-TIME BACKFILL ENTRYPOINT
==================================================

We need a way to run the import for Clean Machine now and later.

1) Add an admin-only route, e.g.:

   - `POST /api/admin/customers/backfill-from-sheets`

   This route should:
   - Resolve the Clean Machine tenantId (or accept a tenantId param with admin checks).
   - Call `googleSheetsCustomerImportService.importForTenant(tenantId)`.
   - Return the summary metrics as JSON.

2) Protect the route:
   - Use whatever admin/auth middleware you already use for admin tools.
   - This should not be callable by public users or tenants.

3) This route should be idempotent:
   - Running it multiple times should:
     - Keep merging data into the same customers.
     - Not create duplicates if the data hasn’t changed.

==================================================
D) ENSURE THE REST OF THE SYSTEM USES THIS CUSTOMER DB
==================================================

1) Confirm that:
   - Campaigns, SMS agent, rewards, etc., already rely on the main customers table.
   - If there are any legacy paths still reading directly from the Google Sheet to “find customers”, convert those paths to use the Postgres customers table instead, using the new importer as the canonical ingestion point.

2) Do NOT change the customer schema; just ensure we are populating it from both:
   - Google Voice SMS import (already working).
   - Google Sheets import (which you are now fixing).

==================================================
E) FINAL CHECKS
==================================================

1) Run `npm run build` and ensure it passes.
2) Run `npm run dev`.
3) For a test run (in development), call the new admin endpoint for Clean Machine and check logs:
   - Expect to see `[SHEETS IMPORT] Summary` with nonzero `newCustomersCreated` and/or `existingCustomersUpdated`.
4) Verify via your existing admin UI or DB inspector:
   - Customer count should increase from ~1,900 toward ~2,400+.
5) Ensure no existing behavior is broken:
   - SMS agent still works.
   - Rewards still work.
   - No changes to Twilio or scheduling logic here.

Stop after implementing this tolerant import + backfill. Do not add extra features like UI dashboards in this phase.
